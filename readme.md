# The design patterns
## Overview

* Observer
    * Customized observer
    * Native Java observer
    * Swing observer
* Decorator
    - Customized decorator 
    - java.io
* Factory
    - Simple factory
    - Factory method
    - Abstract factory
* Singleton
* Adapter
* Facade

__Архитектуры должны быть открытыми для расширения, но закрыты для изменения! Необходимо определить аспекты, которые будут изменяться, и отделить их от тех, которые останутся неизменными.__

## Observer
* Паттерн "Наблюдатель" определяет отношение один-ко-многим между объектами.
* Субъекты обновляют наблюдателей через единый интерфейс.
* Субъект ничего не знает о наблюдателях - кроме того, что они реализуют интерфейс Observer.
* При использовании паттерна возможен как запрос, так и активная доставка данных от субъекта(запрос считается более "правильным").
* Работа кода не должна зависеть от порядка оповещения наблюдателей.
* Java содержит несколько реализаций паттерна "Наблюдатель", включая обобщенную реализацию java.util.Observable.
* Встречается во многих других местах как Listener(JavaBeans, RMI и др.).

## Decorator
Динамически наделяет объект новыми возможностями и является гибкой альтернативой наследования в области расширения функциональности.

* Следует предусмотреть возможность расширения без изменения существующего кода.
* Композиция и делегирование часто используется для динамического добавления нового поведения.
* Типы декораторов соответствуют типам декорируемых компонентов(соответствие достигается путем наследования или реализации интерфейса).
* Декораторы изменяют поведение компонентов, добавляя новую функциональность до и (или) после (или даже вместо) вызовов методов компонентов.
* Компонент может декорироваться любым количеством декораторов.
* Декораторы обычно прозрачны для клиентов компонента (если клиентский код не зависит от конкретного типа компонента).

## Factory

_Принцип инверсии зависимостей:_ код должен зависеть от абстракций, а не от конкретных классов.

Паттерн __Фабричный Метод__ определяет интерфейс создания объекта, но позволяет субклассам выбрать класс создаваемого экземпляра. Таким образом фабричный метод делегирует операцию создания экземпляра субклассам.

Паттерн __Абстрактная фабрика__ предоставляет интерфейс создания семейств взаимосвязанных или взаимозависимых объектов без указания их конкретных классов(Создание разных, но логически связанных объектов).

* Все фабрики инкапсулируют создание объектов.
* Простая фабрика, хоть и не является полноценным паттерном, обеспечивает простой механизм изоляции клиентов от конкретных классов.
* Фабричный метод основан на наследовании: создание объектов делегируется субклассам, реализующим фабричный метод для создания объектов.
* Абстрактная фабрика основана на композиции: создание объектов реализуется в методе, доступ к которому осуществляется через интерфейс фабрики.
* Все фабричные паттерны обеспечивают слабую связанность за счет сокращения зависимости приложения от конкретных классов.
* Задача Фабричного Метода - перемещение создания экземпляров в субклассы.
* Задача Абстрактной Фабрики - создание семейств взаимосвязанных объектов без зависимости от их конкретных классов.

## Singleton

* Паттерн Одиночка гарантирует, что в приложении существует не более одного экземпляра данного класса.
* Предоставляет глобальную точку доступа к этому экземпляра.
* Использует приватный конструктор и статический метод в сочетании со статической переменной.
* Необходимо проанализировать ограничения по производительности и затратам ресурсов и тщательно выбрать реализацию паттерна Singleton для многопоточного приложения.
* До Java 2 версии 5 условная блокировка была небезопасной.
* Нужно быть внимательнее при использовании загрузчиков классов, они могут привести к созданию нескольких экземпляров.
* При использовании ОМЬ 1.2 и ниже, нужно создавать реестр Singleton объектов, что бы предотвратить уничтожение их сборщиком мусора.

## Adapter and Facade

Паттерн Адаптер преобразует интерфейс класса к другому интерфейсу, на который расчитан клиент. Адаптер обеспечивает совместную работу классов, невозможную в обычных условиях из-за несовместимости интерфейсов.

![adapter](/src/img/Adapter.jpeg)

Паттерн Фасад предоставляет унифицированный интерфейс к группе интерфейсов подсистемы. Фасад определяет высокоуровневый интерфейс, упрощающий работу с подсистемой.

* Если понадобилось использовать существующий класс с неподходящим интерфейсом следут использовать "адаптер".
* Если нужно упростить большой интерфейс или семейство сложных интерфейсов следует использовать "фасад".
* "Адаптер" приводит интерфейс к виду, но который расчитан клиент.
* "Фасад" изолирует клиента от сложной подсистемы.
* Объем работы по реализации "адаптера" зависит от размера и сложности целевого интерфейса.
* Реализация "фасада" основана на композиции и делегировании.
* Существуют две разновидности "адаптеров": "адаптеры" объектов и "адаптеры" классов. Для "адаптеров" классов необходимо множественное наследование.
* Для подсистемы можно реализовать несколько фасадов.